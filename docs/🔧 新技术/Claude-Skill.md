---
title: claude-skills
tags:
  - 技术新闻

---

今年年底，Anthropic 为 Claude 系列 AI 推出了 Claude Skills 功能。Claude Skills 是一种包含指令、脚本和资源的模块化技能包，Claude 在执行具体任务时可按需加载提高表现，可用于自动化重复流程、定制专业能力等。

# Claude Skills

## 1. 是什么？

**Claude Skills（也常被叫 Agent Skills）** 可以理解成：给 Claude 准备的一套“可复用工作流/操作手册”。它通常以**一个文件夹**的形式存在，里面放着：

- **说明与规则**（例如你的写作口吻、公司规范、命名规则、流程步骤）
- **脚本或小工具**（需要时可以执行一些自动化动作）
- **参考资料/模板**（例：品牌手册、表格模板、报告模板）

Claude 在做任务时会**按需加载**这些内容，用来更稳定地按你的方式干活，而不是每次都从零开始理解你的偏好。

## 2. 为什么？它解决什么问题？可以做哪些事？

没有 Skills 的时候，你会经常遇到：

- 同一类任务要反复交代规则（格式、口吻、字段、步骤）
- 输出风格不稳定（这次像这样，下次又变了）
- 复杂流程拆解麻烦（“先做A，再做B，再生成C文档”）

有 Skills 后，你相当于把这些“组织经验/个人习惯”封装起来，让 Claude **更像一个被你培训过的助理**。

---

从开发者的角度来看，Claude Skills 最有价值的点是：把团队/项目里那些“反复说、反复做”的工程规则和流程固化成可复用的技能包，让 Claude 在合适的时机自动按规范执行。Claude Code 文档里也明确了 Skill 可以带指令+资源，并且还能限制允许使用的工具（比如只允许读文件、grep，不允许写入）。

例如，从项目开发的角度，可以将编码规范、脚手架和常见模式“模板化”，包括：

- **统一项目风格**：例如 Python：类型标注、异常处理、日志、命名规则、目录结构；前端：组件命名、状态管理约定。

- **生成脚手架**：新模块/新特性自动按你项目习惯生成：目录、README、配置、基础测试、示例用法。

- **自动补齐“配套件”**：你让它加一个功能，它会按 Skill 规则同时补：

  - CLI 参数/配置项

  - 文档（README/CHANGELOG）

  - 单测/集成测试

  - 运行脚本/Makefile 目标

- **安全写代码**：可以把 Skill 设置成“默认只读+提出修改建议”，或者明确“必须先跑测试再提交修改”。（文档里有 `allowed-tools` 这种限制工具的方式）

## 3. 怎么做？如何使用 Claude Skills？



# 补充：个人问题

## 概念区分

Claude Skills 的本质仍然是在为代理添加新的能力，使其脱离单纯的 LLM 的范畴，并提高代理在项目开发中的能力，但是在这个方向上，此前已经有很多技术实现，比如：Agent tools、MCP、.cursorrules 等技术，他们的工作内容和目标似乎是有所重叠的，所以接下来对不同概念进行简单的区分。

我们可以从两个角度进行区分：

- 维度对比：从作用域、载体、是否可执行、接入外部能力、典型用法等维度进行对比；
- 工作内容：从谁在“规定行为”、谁在“接工具”、谁在“跨应用标准化”、谁在IDE中“约束风格”，等角度进行区分；

---

首先是下定义阶段：

1. **Claude Skills**：Claude（尤其是Claude Code）的可加载“技能包”——一组指令+资源/脚本+（可选）工具权限约束，让 Claude 在特定任务上按照固定的流程做事；
2. **MCP（Model Context Protocol）**：一个开放协议——让“客户端（IDE/应用）”用统一方式连上“服务器”，服务器可暴露 Tools / Resources / Prompts 等能力给模型使用。
3. **Agent tools（工具调用/函数调用）**：泛称——模型按 schema 选择并调用外部函数/工具来完成任务（不特指某一家）。
4. **.cursorrules（Cursor 规则）**：Cursor IDE 里给 AI 的“仓库级/项目级规则文件”，主要用于约束风格、习惯、输出结构、上下文提示。同时 Cursor 近版本也在推进新的规则文件形态（如 `.cursor/rules/*.mdc` 等）。

---

关键区分：他们分别在哪一层起作用？

| 概念                        | 属于哪一层                          | 核心作用                                                     | “能不能做事”                                      |
| --------------------------- | ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| Claude Skills               | **Claude 生态里的“可复用工作流包”** | 让 Claude 按你的 SOP 工作；可带脚本/模板/数据，并可约束能用哪些工具（Claude Code） | ✅ 能（通过 Claude 自身工具/脚本执行）             |
| MCP                         | **跨应用/跨工具的“连接协议”**       | 统一“发现工具/读取资源/调用工具/拿 prompt 模板”的方式        | ✅ 能（但它本身是协议；真正执行在 MCP server）     |
| Agent tools                 | **最底层的“工具调用范式”**          | 给模型一组函数 schema，模型决定何时调用、传什么参数          | ✅ 能（取决于工具实现）                            |
| .cursorrules / Cursor Rules | **IDE 内的“行为/风格约束”**         | 让 Cursor 的 AI 更懂你的项目规范、写法、偏好（偏约束/提示，不是协议） | ⚠️ 通常不直接执行外部动作（更多是“怎么写/怎么改”） |

**Agent tools** 是“怎么调用工具”的通用机制；**MCP** 是“用统一协议把工具/资源端出来”；**Claude Skills** 是“Claude 端把流程+资源打包复用”；**.cursorrules** 是“在 Cursor 里约束 AI 的行为风格”。

---

> 到这里为止，其实我个人的问题是这样的：比如说我用 Cursor 多，那么我完全可以通过 cursorrules 定义规则和指令，通过 MCP 和 tools（比如我在进行智能体开发）定义工具、通过 Chroma 等方法进行资源管理、最后用类似 Human-in-the-loop 等中间件进行工具权限约束，这不也可以达到 Claude Skills 的目的吗？

下面是针对这个问题的一点总结：

首先，用这样的思路理解和“平替” Claude Skills 本身的方向是没有问题的，如果用 Cursor 做主战场，确实可以用一套“规则 + 工具协议 + 资源库 + 权限中间件”的组合，把 **Claude Skills 想解决的很多问题**都复刻出来。

但是，有点类似于曾经的 Function Calling 和 MCP 的区别，关键的差别在于：**“能不能做到”** vs **“做到的成本/一致性/可迁移性/产品级体验”**。Claude Skills 更像是 Anthropic 把问题中描述的这套体系做成了**官方约定俗成的封装层**（一个“可分发的能力包”），而在 Cursor 体系里做的是“自定义平台”。

我们可以从以下几个视角拆看来看这两种方案：

1. 能不能“平替”？

   从功能覆盖上，这套 cursor 方案确实可以覆盖到 Skills 的核心目标。

2. 为什么还会有 Claude Skills？

   - 封装粒度：cursor 方案是一个“工程拼装”，但是 Skills 是一个“可携带的能力包”；

     **Skills 的价值**在于把这些“对齐”成一个**统一可搬运的包**：别人拿到一个 Skill，就能按同样的方式使用；而你这套需要别人把整套工程拼好。

   - 选择与路由：Skills 更强调“什么时候用哪个”，而不仅仅是“我能用什么”；

     Skills 作为产品形态，通常会把包括多个 tools/agents/rules 的选择策略、出发条件/优先级/冲突解决、失败回退等功能做成“默认体验”：**模型更容易自动选中合适的 Skill**，或按 Skill 的描述进行稳定路由，而不是手动对每一个环境进行拼装；

   - 版本化与分发：Skills 更像“可版本管理的工作资产”

     尽管 cursor 方案也可以用包括 git 在内的方式进行管理，但是在工程上仍然有可能会遇到规则与工具结构变更不同步、环境差异导致不可复现、新机器配置成本等问题，而 Skills 的设计目标之一就是让“技能”成为一种**一等资产**：更容易分享、复用、更新、回滚。

   - 运维接口：Skills 往往会围绕“任务级复用”提供更清晰的运维接口

     自建体系也能做日志、trace、成本统计、失败率等，但得用户自己实现和治理。
     而 Skills 作为“任务资产”，往往天然会带来更清晰的：输入输出规范、运行步骤、复用边界、评估基线等内容。

最后，我们的结论是：是的， Cursor + MCP + 向量库 + HITL 的方案确实能实现 Skills 的主要目的，但是 Claude Skills 的不同点不在“能力上限”，而在“把这套能力产品化、打包化、可复用/可迁移/易治理”。

---

> 这让我又想到了一个事情，大约一年前，Anthropic 推出了 MCP 协议，用于取代和统一当时混乱的 function calling 局面，此时此刻恰如彼时彼刻，虽然功能和目的大家都可以做到，但是 Anthropic 通过推出统一的“协议”，实现了领域内的互相打通和 “大一统”，是这样的吗？

这个思路的核心逻辑确实是有据可循的：

- **Function calling / tools**：解决的是“模型怎么把一个意图变成结构化参数，然后调用某个函数”——这是**能力层**（单次调用的语义和格式）。

- **MCP**：解决的是“外部世界怎么把一堆工具/资源/提示模板，以统一方式‘挂’给模型/客户端”——这是**连接层/生态层**（发现、加载、调用、读资源、权限等的统一“插口”）。

所以说“虽然都能做到，但统一协议带来互通和大一统”——**方向没错**：协议化会带来更强的可组合性和可复用性。

但是并不是同一层面的统一，所以 MCP 的价值不是“让模型能调用工具”（function calling 已经能），而是让工具提供方、客户端、模型之间少很多“定制胶水”。

工程上常见的现实是：

- 会出现多个协议/标准并存（有的偏简单、有的偏企业治理、有的偏特定平台）
- 但**有一个被广泛采纳的协议**时，生态会明显更容易互通

所以可以把 MCP 的意义理解为把“工具接入”从 **每家自定义推向可互操作** 的方向，生态摩擦大幅下降。

然后我们再把这条思路扩展到 Claude Skills 阶段，就会发现这样一个递进关系：

1. **Function calling**：解决“怎么调用一次工具”；
2. **MCP**：解决“工具/资源怎么标准化地接进来、被发现、被调用”；
3. **Skills**：解决“把一套流程（SOP）+资源+（可选）工具约束 打包成可复用资产”，让任务执行更稳定。

这三者其实是递进关系：**调用机制 → 接入协议 → 工作流资产化**。

